/**
 * File:	modules/SMTData.ycp
 * Package:	Configuration of SMT
 * Summary:	SMT global data and functions
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 *
 * $Id:$
 */

{
    textdomain "smt";

    module "SMTData";

    import "Message";
    import "Service";
    import "Report";
    import "FileUtils";
    import "String";
    import "Label";
    import "Popup";
    import "PackageSystem";
    import "Wizard";
    import "Progress";
    import "Directory";

    map <string, map <string, string> > all_credentials = $[];

    // script entered into a crontab
    string cron_mirror_script = "/usr/bin/smt-mirror.pl";
    // cron 
    string path_to_cron = "/etc/smt.d/novell.com-smt";

    string path_to_sync_script = "/usr/sbin/smt-ncc-sync";
    string user_for_sync_script = "root";

    string server_cert = "/etc/ssl/certs/YaST-CA.pem";
    string apache_cert = "/srv/www/htdocs/smt.crt";

    list <map> smt_cron_settings = [];

    boolean first_run = nil;

    string first_run_file = sformat ("%1/smt-already-adjusted", Directory::vardir);

    boolean smt_enabled = nil;

    list <string> smt_services = ["smt"];

    /**
     * Returns list of scheduled NU mirrorings.
     *
     * @return list <map>
     *
     * @struct [
     *   $[
     *     "command":"...",
     *     "day_of_month":"...",
     *     "day_of_week":"...",
     *     "hour":"...",
     *     "minute":"...",
     *     "month":"...",
     *     "user":"...",
     *   ],
     *   ...
     * ]
     */
    global list <map> GetCronSettings () {
	return smt_cron_settings;
    }

    /**
     * Adds new cron job.
     *
     * @param map new_cron_job
     *
     * @see GetCronSettings()
     */
    global void AddNewCronJob (map new_cron_job) {
	new_cron_job["user"] = user_for_sync_script;

	smt_cron_settings = add (smt_cron_settings, new_cron_job);
    }

    /**
     * Replaces the current cron job settings with new ones.
     *
     * @param integer cron_job_id (offset)
     * @param map new_settings
     *
     * @see GetCronSettings()
     */
    global void ReplaceCronJob (integer cron_job_id, map new_settings) {
	if (cron_job_id == nil || cron_job_id < 0) {
	    y2error ("Undefined offset: %1", cron_job_id);
	    return;
	}

	new_settings["user"] = user_for_sync_script;

	smt_cron_settings[cron_job_id] = new_settings;
    }

    /**
     * Removes a current cron job.
     *
     * @param integer cron_job_id (offset)
     *
     * @see GetCronSettings()
     */
    global void RemoveCronJob (integer cron_job_id) {
	if (cron_job_id == nil || cron_job_id < 0) {
	    y2error ("Undefined offset: %1", cron_job_id);
	    return;
	}

	smt_cron_settings = remove (smt_cron_settings, cron_job_id);
    }

    /**
     * Reads whether the configuration process has been already done.
     */
    global void ReadFirstRun () {
	if (! FileUtils::Exists (first_run_file)) {
	    y2milestone ("File %1 doesn't exist -> this is a first-run", first_run_file);
	    first_run = true;
	} else {
	    y2milestone ("Not a first-time run...");
	    first_run = false;
	}
    }

    global boolean GetFirstRun () {
	return first_run;
    }

    /**
     * Writes that the configuration has been already done.
     */
    global void WriteFirstRunStatus () {
	if (! (boolean) SCR::Write (.target.ycp, String::Quote (first_run_file), [])) {
	    y2error ("Cannot create file %1", first_run_file);
	}
    }

    /**
     * Returns whether the current YaST run is the first run of the SMT configuration.
     */
    global boolean IsFirstRun () {
	return first_run;
    }

    global void ReadSMTServiceStatus () {
	if (IsFirstRun() == nil) {
	    y2error ("Cannot evaluate first_run!");
	} else if (IsFirstRun() == true) {
	    smt_enabled = true;
	    return;
	}

	// default (changed later to false if something doesn't work)
	smt_enabled = true;

	foreach (string one_service, smt_services, {
	    if (! Service::Enabled (one_service)) {
		smt_enabled = false;
	    }
	});
    }

    global boolean GetSMTServiceStatus () {
	return smt_enabled;
    }

    global void SetSMTServiceStatus (boolean new_status) {
	if (new_status == nil) {
	    y2error ("Cannot set 'nil' status!");
	    return;
	}

	smt_enabled = new_status;
    }

    global boolean WriteSMTServiceStatus () {
	if (GetSMTServiceStatus() == true) {
	    foreach (string one_service, smt_services, {
		Service::Enable (one_service);
		Service::Start (one_service);
	    });
	} else {
	    foreach (string one_service, smt_services, {
		Service::Stop (one_service);
		Service::Disable (one_service);
	    });
	}

	return true;
    }

    /**
     * Returns value for credentials entry.
     *
     * @see SetCredentials
     *
     * @param string entry_name
     * @return string value
     */
    global string GetCredentials (string location, string entry_name) {
	if (! haskey (all_credentials, location)) {
	    y2warning ("Key %1 not defined", location);
	    return "";
	} else if (! haskey (all_credentials[location]:$[], entry_name)) {
	    y2warning ("Key %1/%2 not defined", location, entry_name);
	    return "";
	}

	return all_credentials[location, entry_name]:"";
    }

    /**
     * Sets name/value credential pairs.
     *
     * @see GetCredentials
     *
     * @param string entry_name
     * @param string value
     */
    global void SetCredentials (string location, string entry_name, string value) {
	if (! haskey (all_credentials, location)) {
	    all_credentials[location] = $[];
	}

	all_credentials[location, entry_name] = value;
    }

    /**
     * Reads the current SMT credentials into the memory
     *
     * @return boolean if successful
     */
    global boolean ReadCredentials () {
	all_credentials = $[];

	all_credentials["NU"] = $[];

	foreach (string one_entry, ["NUUser", "NUPass", "NUUrl"], {
	    SetCredentials ("NU", one_entry, (string) SCR::Read (add (.smt_conf.value.NU, one_entry)));
	});

	all_credentials["LOCAL"] = $[];

	foreach (string one_entry, ["nccEmail", "reportEmail", "url"], {
	    SetCredentials ("LOCAL", one_entry, (string) SCR::Read (add (.smt_conf.value.LOCAL, one_entry)));
	});

	all_credentials["DB"] = $[];

	foreach (string one_entry, ["user", "pass"], {
	    SetCredentials ("DB", one_entry, (string) SCR::Read (add (.smt_conf.value.DB, one_entry)));
	});

	return true;
    }

    /**
     * Writes the current credentials to the SMT configuration file.
     *
     * @return boolean if successful
     */
    global boolean WriteCredentials () {
	boolean failed = false;

	foreach (string base_key, map <string, string> current_credentials, all_credentials, {
	    foreach (string key, string value, current_credentials, {
		if (! (boolean) SCR::Write (add (add (.smt_conf.value, base_key), key), value)) {
		    y2error ("Cannot write to smt.conf/%1/%2", base_key, key);
		    failed = true;
		}
	    });
	});

	if (failed == false) {
	    if (! (boolean) SCR::Write (.smt_conf, nil)) {
		y2error ("Cannot write to smt.conf");
		failed = true;
	    }
	}

	return (failed == false);
    }

    /**
     * Function checks and adjusts the apache configuration
     * to be usable by SMT.
     *
     * @return boolean if successful
     */
    global boolean CheckAndAdjustApacheConfiguration () {
	string apache_conf_file = "/etc/sysconfig/apache2";

	boolean apache_conf_changed = false;

	if (! (boolean) SCR::RegisterAgent (.http_server_conf, `ag_ini (`SysConfigFile (apache_conf_file)))) {
	    y2error ("Cannot register agent");
	    Message::CannotWriteSettingsTo (apache_conf_file);
	    return false;
	}

	// "perl" in /etc/sysconfig/apache2:APACHE_MODULES
	string ap_modules = (string) SCR::Read (.http_server_conf.APACHE_MODULES);
	string ap_modules_old = ap_modules;

	list <string> ap_modules_l = splitstring (ap_modules, " \t");
	ap_modules_l = filter (string one_ap_module, ap_modules_l, {
	    return (one_ap_module != nil && one_ap_module != "");
	});
	ap_modules_l = toset ((list <string>) union (ap_modules_l, ["perl"]));
	ap_modules = mergestring (ap_modules_l, " ");

	if (ap_modules != ap_modules_old) {
	    y2milestone ("Writing APACHE_MODULES");
	    SCR::Write (.http_server_conf.APACHE_MODULES, ap_modules);
	    apache_conf_changed = true;
	}

	// SSL in /etc/sysconfig/apache2:APACHE_SERVER_FLAGS
	string ap_serflag = (string) SCR::Read (.http_server_conf.APACHE_SERVER_FLAGS);
	string ap_serflag_old = ap_serflag;

	list <string> ap_serflag_l = splitstring (ap_serflag, " \t");
	ap_serflag_l = filter (string one_ap_serflag, ap_serflag_l, {
	    return (one_ap_serflag != nil && one_ap_serflag != "");
	});
	ap_serflag_l = toset ((list <string>) union (ap_serflag_l, ["SSL"]));
	ap_serflag = mergestring (ap_serflag_l, " ");

	if (ap_serflag != ap_serflag_old) {
	    y2milestone ("Writing APACHE_SERVER_FLAGS");
	    SCR::Write (.http_server_conf.APACHE_SERVER_FLAGS, ap_serflag);
	    apache_conf_changed = true;
	}

	// Something has been changed
	// Apache conf needs writing
	// and Apache service needs restarting
	if (apache_conf_changed) {
	    y2milestone ("Writing sysconfig/apache conf");
	    if (! (boolean) SCR::Write (.http_server_conf, nil)) {
		y2error ("Cannot write apache2 conf");
		Message::CannotWriteSettingsTo (apache_conf_file);
		return false;
	    }
	}

	if (! (boolean) SCR::UnregisterAgent (.http_server_conf)) {
	    y2error ("Cannot unregister agent");
	}

	return true;
    }

    global boolean RunSmallSync () {
	if (! FileUtils::Exists (path_to_sync_script)) {
	    y2error ("Sync script doesn't exist");
	    Report::Error (sformat (_("Synchronization script %1 does not exist.

Please, check your SMT installation."), path_to_sync_script));
	    return false;
	}

	map cmd_out = (map) SCR::Execute (.target.bash_output, path_to_sync_script);
	if (cmd_out["exit"]:-1 != 0) {
	    UI::OpenDialog (
		`HBox (
		    `VSpacing (19),
		    `VBox (
			`HSpacing (70),
			`Left (`Label (_("Running the synchronization script failed."))),
			`RichText (
			    `opt (`hstretch, `vstretch),
			    sformat (_("<p><b>Details:</b></p>
<p><b>stdout:</b> %1</p>
<p><b>stderr:</b> %2</p>"), cmd_out["stdout"]:"", cmd_out["stderr"]:"")
			),
			`PushButton (`id (`ok), `opt(`default), Label::OKButton())
		    )
		)
	    );
	    UI::UserInput();
	    UI::CloseDialog();
	}

	return true;
    }

    global void ReadCronSettings () {
	if (! FileUtils::Exists (path_to_cron)) {
	    y2milestone ("Creating file %1", path_to_cron);
	    map cmd = (map) SCR::Execute (.target.bash_output, sformat ("touch '%1'", String::Quote (path_to_cron)));

	    if (cmd["exit"]:-1 != 0) {
		y2error ("Cannot create file %1: %2", path_to_cron, cmd);
	    }
	}

	smt_cron_settings = (list <map>) SCR::Read (.smt_cron);
    }

    global boolean WriteCronSettings () {
	string service_name = "cron";

	if (smt_cron_settings == nil || size (smt_cron_settings) == 0) {
	    if (FileUtils::Exists (path_to_cron) && ! (boolean) SCR::Execute (.target.remove, path_to_cron)) {
		y2error ("Cannot remove %1 cron-file", path_to_cron);
	    } else {
		y2milestone ("No cron settings at all");
		return true;
	    }
	}


	if (! (boolean) SCR::Write (.smt_cron, smt_cron_settings)) {
	    y2error ("Writing cron failed");
	    Report::Error (_("Cannot write cron settings."));
	    return false;
	}

	if (size (smt_cron_settings) > 0) {
	    if (! Service::Enabled (service_name)) {
		Service::Enable (service_name);
	    } else {
		y2milestone ("Service cron already enabled, skipping ...");
	    }
	}

	if (! Service::Restart (service_name)) {
	    y2error ("Reloading %1 failed", service_name);
	    // TRANSLATORS: error message, %1 is replaced with a service-name
	    Report::Error (sformat (_("Reloading service has %1 failed."), service_name));
	    return false;
	}

	return true;
    }

    boolean ca_already_called = false;

    /**
     * Handles a missing CA certificate.
     * Returns boolean value whether CA checking should be finished.
     *
     * @return boolean whether to finish the CA checking
     */
    boolean HandleMissingCACert () {
	y2milestone ("CA file %1 doesn't exist", server_cert);
	string ca_mgm_package = "yast2-ca-management";

	if (Popup::AnyQuestion (
	    // TRANSLATORS: Pop-up question headline
	    _("Missing Server Certificate"),
	    // TRANSLATORS: Pop-up question, %1 is replaced with a file name
	    sformat (_("Server certificate %1 doesn't exist.
Would you like to run CA management to create one?

Server certificate is vitally important for NU server to support SSL."),
		server_cert),
		_("&Run CA management"),
		_("&Skip"),
		(ca_already_called ? `focus_no : `focus_yes))
	) {
	    // Package needs to be installed
	    if (PackageSystem::CheckAndInstallPackagesInteractive ([ca_mgm_package])) {
		y2milestone ("Running ca_mgm");
		ca_already_called = true;

		Wizard::OpenNextBackDialog();
		boolean progress_orig = Progress::set (false);
		any ret = WFM::call ("inst_proposal", [$["proposal":"service"]]);
		y2milestone ("Service proposal returned: %1", ret);
		Progress::set (progress_orig);
		Wizard::CloseDialog();

		return false;
	    // Package is not installed and couldn't be installed
	    } else {
		Report::Error (sformat (
		    _("Cannot run CA management bacause package %1 is not installed."),
		    ca_mgm_package
		));
		    return true;
	    }
	} else {
	    y2warning ("User doesn't want to run CA management.");
	    return true;
	}
    }

    /**
     * Function checks whether a server certificate exists and copies it
     * to the apache directory. If a server certificate doesn't exist,
     * user is offered to run the CA management.
     *
     * @return boolean if successful
     */
    global boolean WriteCASettings () {
	boolean ret = false;

	// check the existence of file and offer to run CA managament
	// if it doesn't then check the existence again... and again...
	while (true) {
	    // Server certificate is missing
	    if (! FileUtils::Exists (server_cert)) {
		if (HandleMissingCACert()) {
		    break;
		}

	    // Server certificate exists
	    } else {
		ret = true;
		break;
	    }
	}

	return ret;
    }
}
