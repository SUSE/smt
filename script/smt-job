#!/usr/bin/perl

###############################################################################
## Copyright (c) 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;

use SMT::CLI;
use SMT::Utils;
use SMT::Client;
use SMT::JobQueue;
use SMT::Job;

use Text::ASCIITable;
use File::Basename;
use Locale::gettext ();
#use UNIVERSAL 'isa';
use POSIX ();     # Needed for setlocale()

use Data::Dumper;

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

use constant JOB_TYPE    =>
  {
    # Maps JOB_TYPE ID to JOB_TYPE NAME
    1       => 'patchstatus',
    2       => 'softwarepush',
    3       => 'update',
    4       => 'execute',
    5       => 'reboot',
    6       => 'configure',
    7       => 'wait',
    8       => 'eject',

    # Maps JOB_TYPE NAME to JOB_TYPE ID
    'patchstatus'   =>      1,
    'softwarepush'  =>      2,
    'update'        =>      3,
    'execute'       =>      4,
    'reboot'        =>      5,
    'configure'     =>      6,
    'wait'          =>      7,
    'eject'         =>      8,
  };

use constant JOB_STATUS   =>
  {
    # map JOB_STATUS ID to JOB_STATUS string
    0  => 'queued',
    1  => 'successful',
    2  => 'failed',
    3  => 'denied',

    # map JOB_STATUS string to JOB_STATUS ID
    'queued'     => 0,
    'successful' => 1,
    'failed'     => 2,
    'denied'     => 3,
  };


#### START LOCAL FUNCTIONS ####

sub getJobTypeID($)
{
    my $q = shift || return undef;

    if ( $q =~ /^\d+$/ )
    {
        return $q if exists JOB_TYPE->{$q};
        return undef;
    }
    elsif ( exists JOB_TYPE->{$q}  )
    {
        return  JOB_TYPE->{$q};
    }

    return undef;
}



#### END LOCAL FUNCTIONS ####


if(!SMT::Utils::dropPrivileges())
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

# connect to database
my ($cfg, $dbh) = SMT::CLI::init();
if (! defined $dbh) {
    print __("Cannot connect to database");
    exit 3;
}


my ($verbose, $help, $quiet) = undef;
my ($create, $edit, $delete, $list, @guid, $jobid, $deleteall, $type, $name, $description, $targeted, $expires, $timelag, $finished, $verbosejob, $persistent, $parent, @SWpackagelist, $SWforce, $SWagree, $EXECcommand, $WAITtime, $WAITstatus, $CDAction, $autoPatchstatus) = undef;

use Getopt::Long;
&Getopt::Long::Configure( 'no_autoabbrev', 'no_ignore_case');
if (! &Getopt::Long::GetOptions(
         'help|h' => \$help,
         'verbose|v=i' => \$verbose,
         'quiet|q' => \$quiet,
         # the four basic modes of smt job
         'create|c' => \$create,
         'edit|e' => \$edit,
         'delete|d' => \$delete,
         'list|l' => \$list,
         # job identifier
         'guid|g=s' => \@guid,
         'jobid|j=i' => \$jobid,
         'deleteall|A' => \$deleteall,
         # data fields for create and edit:
         'type|t=s' => \$type,
         'name|n=s' => \$name,
         'description=s' => \$description,
         'targeted=s' => \$targeted,
         'expires=s' =>  \$expires,
         'timelag=s' =>  \$timelag,
         # general switches
         'finished|f!' => \$finished,
         'verbosejob|V!' => \$verbosejob,
         'persistent!' => \$persistent,
         'parent=i' => \$parent,
         # job specific arguments
         'package|P=s@' => \@SWpackagelist,
         'forceinstall|F!' => \$SWforce,
         'agreelicense!' => \$SWagree,
         'exec|X=s' => \$EXECcommand,
         'waittime=i' => \$WAITtime,
         'waitstatus=i' => \$WAITstatus,
         'action=s' => \$CDAction,
         'autopatchstatus!' => \$autoPatchstatus,
) )
{
  print __("Invalid arguments.")."\n";
  exit 4;
};



if ( defined $help and ( $help == 1 ) )
{
  print basename($0) . " : " . __("list, create, edit and delete jobs from SMT job queue")."\n";
  print "\n";
  print __("Usage:"). ' ' . basename($0) . ' ' . __("<operation mode>  <parameters>")."\n";
  print "\n";
  print "   --help        (-h)        : " . __("show this help")."\n";
  print "   --verbose     (-v) <level>: " . __("show detailed job information")."\n";
  print "                               " . __("level can be a number from 1 to 3")."\n";
  print "   --quiet       (-q)        : " . __("quiet mode, suppress success messages")."\n";
  print "\n";
  print __("operation modes")."\n";
  print "   --list        (-l) : " . __("list jobs (default)")."\n";
  print "   --create      (-c) : " . __("create job")."\n";
  print "   --edit        (-e) : " . __("edit job")."\n";
  print "   --delete      (-d) : " . __("delete job")."\n";
  print "\n";
  print __("main parameters")."\n";
  print "   --guid        (-g) <guid> : " . __("the clients guid")."\n";
  print __("                               can be used multiple times when creating a job")."\n";
  print "   --jobid       (-j) <id>   : " . __("the jobid")."\n";
  print __("                        will be ignored when creating a job")."\n";
  print "   --deleteall   (-A)        : " . __("allows to omit either the guid or the jobid parameter")."\n";
  print __("                       the missing parameter will then match all")."\n";
  print "\n";
  print __("parameters to search for or change")."\n";
  print "   --type        (-t) <type> : " . __("job type (name or its id)")."\n";
  print "   --name        (-n) <name> : " . __("job name")."\n";
  print "   --description      <desc> : " . __("job description")."\n";
  print "   --parent           <id>   : " . __("parent job, describes a dependency")."\n";
  print "   --verbosejob  (-V)        : " . __("verbosity of job")."\n";
  print "   --persistent              : " . __("persistency of job")."\n";
  print "   --finished                : " . __("finds finished jobs")."\n";
  print "\n";
  print __("parameters for timing (timeformat: see below)")."\n";
  print "   --targeted                : " . __("targeted date and time")."\n";
  print "   --expires                 : " . __("date and time when job expires")."\n";
  print "   --timelag                 : " . __("time interval for persistent jobs")."\n";
  print "\n";
  print __("job specific parameters (only for creating a job)")."\n";
  print '  '.__("for software push jobs")."\n";
  print "   --package      (-P) <pack>: " . __("a package name")."\n";
  print __("                               can be used multiple times")."\n";
  print "   --forceinstall (-F)       : " . __("enforce the installation")."\n";
  print "   --agreelicense            : " . __("auto-agree to licenses")."\n";
  print "   --autopatchstatus         : " . __("add a following patchstatus job automatically (enabled by default)")."\n";
  print '  '.__("for execute jobs")."\n";
  print "   --exec         (-X) <cmd> : " . __("the command to execute")."\n";
  print '  '.__("for wait jobs")."\n";
  print "   --waittime         <time> : " . __("time in seconds the job should take")."\n";
  print "   --waitstatus       <exit> : " . __("exit code for the job to return with")."\n";
  print '  '.__("for eject jobs")."\n";
  print "   --action         <action> : " . __("action of CD or DVD tray: 'open'|'close'|'toggle'")."\n";
  print "\n";
  print __("time format")."\n";
  print "   targeted/expires          : " . __("'YYYY-MM-DD[-HH:MM[:SS]]'")."\n";
  print "   timelag                   : " . __("'HH:MM[:SS]'")."\n";
  print "\n";
  print __("negatable parameters")."\n";
  print "   --finished        :  --no-finished"."\n";
  print "   --persistent      :  --no-persistent"."\n";
  print "   --verbosejob      :  --no-verbosejob"."\n";
  print "   --forceinstall    :  --no-forceinstall"."\n";
  print "   --agreelicense    :  --no-agreelicense"."\n";
  print "   --autopatchstatus :  --no-autopatchstatus"."\n";
  print "\n";
  print __("available job types")."\n";
  print "   1 : patchstatus   : " . __("Request patchstatus information from the client.") . "\n";
  print "   2 : softwarepush  : " . __("Install software on the client.") . "\n";
  print "   3 : update        : " . __("Install available updates.") . "\n";
  print "   4 : execute       : " . __("Execute custom command on the client.") . "\n";
  print "   5 : reboot        : " . __("Reboot the client.") . "\n";
  print "   6 : -reserved-    : " . __("Reserved") . "\n";
  print "   7 : wait          : " . __("Wait and return with specified status (for debugging).") . "\n";
  print "   8 : eject         : " . __("Eject CD/DVD drive (for debugging).") . "\n";
  print "   0 : -invalid job- : " . __("Invalid job type.") . "\n";
  print '       '.__("Jobs of type 0 will be cleaned up regularly.")."\n";

  exit 0;
}

########################################################################################
#
# get and check all passed parameters
#

$autoPatchstatus = defined $autoPatchstatus ? $autoPatchstatus:1;

my %query = ();

my $GUID = undef;
if (@guid && @guid > 0)
{
    # searching only supports one guid
    $query{'GUID'} = $guid[0];
    # for methods that only operate on one guid
    $GUID = $guid[0];
}
else
{
    @guid = undef;
}
$query{'ID'} = $jobid if (defined $jobid);

my $typeID = getJobTypeID($type);
if ( defined $type && not defined $typeID )
{
    print "Job type unkown.\n";
    exit 4;
}
$query{'TYPE'} = $typeID if (defined $typeID);
$query{'NAME'} = $name if (defined $name);
$query{'DESCRIPTION'} = $description if (defined $description);
# check time format
$query{'TARGETED'} = $targeted if (defined $targeted);
$query{'EXPIRES'} = $expires if (defined $expires);
$query{'TIMELAG'} = $timelag if (defined $timelag);


if ( exists $query{'TARGETED'} )
{
    if ( $query{'TARGETED'} !~ /^\d{4}-\d{2}-\d{2}([-_+ ]\d{2}:\d{2}(:\d{2})?)?$/ )
    {
	print __("Invalid time format for 'targeted' time.")."\n";
	exit 4;
    }
}
if ( exists $query{'EXPIRES'} )
{
    if ( $query{'EXPIRES'} !~ /^\d{4}-\d{2}-\d{2}([-_+ ]\d{2}:\d{2}(:\d{2})?)?$/ )
    {
	print __("Invalid time format for 'expires' time.")."\n";
	exit 4;
    }
}
if ( exists $query{'TIMELAG'} )
{
    if ( $query{'TIMELAG'} !~ /^\d{2}:\d{2}(:\d{2})?$/ )
    {
	print __("Invalid time format for 'timelag'.")."\n";
	exit 4;
    }
}


if (defined $finished)
{
    $query{'FINISHED+'} = 'NULL' if ($finished);
    $query{'FINISHED-'} = 'NULL' if (not $finished);
}

if (defined $verbosejob)
{
    $query{'VERBOSE'} =  $verbosejob ? 1:0;
}
if (defined $persistent)
{
    $query{'PERSISTENT'} = $persistent ? 1:0;
}
$query{'PARENT_ID'} = $parent if (defined $parent);

my %para = ();
$para{'PACKAGELIST'} = \@SWpackagelist if (@SWpackagelist);
$para{'SWFORCE'} = $SWforce if (defined $SWforce);
$para{'EXECCOMMAND'} = $EXECcommand if (defined $EXECcommand);
$para{'WAITTIME'} = $WAITtime if (defined $WAITtime);
$para{'WAITSTATUS'} = $WAITstatus if (defined $WAITstatus);
$para{'ACTION'} = $CDAction if (defined $CDAction);




#######################################################################################
#
# MAIN routine
#


my $JobQ = SMT::JobQueue->new({ 'dbh' => $dbh });
my $Job = SMT::Job->new({ 'dbh' => $dbh });
## my $Client = SMT::Client->new({'dbh' => $dbh});

my $opc = 0;
$opc++ if (defined $create);
$opc++ if (defined $edit);
$opc++ if (defined $delete);
$opc++ if (defined $list);
if ( $opc > 1 )
{
    print __("Please define only one operation mode.")."\n";
    exit 3;
}


if ( defined $create )
{
    ## CREATE ##

    if ( not defined $typeID )
    {
        print __("The job type is invalid.")."\n";
        exit 3;
    }
    if ( not defined $GUID )
    {
        print __("The guid is invalid.")."\n";
        exit 3;
    }

    $Job->newJob( @guid > 0 ? undef:$GUID, undef, $typeID, undef );

    # fill in parameters if they are specified - maybe overwritten in job type handling below
    $Job->{'name'}        = $query{'NAME'}        if ( exists $query{'NAME'}        && defined $query{'NAME'} );
    $Job->{'description'} = $query{'DESCRIPTION'} if ( exists $query{'DESCRIPTION'} && defined $query{'DESCRIPTION'} );
    $Job->{'verbose'}     = $query{'VERBOSE'}     if ( exists $query{'VERBOSE'}     && defined $query{'VERBOSE'} );
    $Job->{'persistent'}  = $query{'PERSISTENT'}  if ( exists $query{'PERSISTENT'}  && defined $query{'PERSISTENT'} );
    $Job->{'parent_id'}   = $query{'PARENT_ID'}   if ( exists $query{'PARENT_ID'}   && defined $query{'PARENT_ID'} );
    $Job->{'targeted'}    = $query{'TARGETED'}    if ( exists $query{'TARGETED'}    && defined $query{'TARGETED'} );
    $Job->{'expires'}     = $query{'EXPIRES'}     if ( exists $query{'EXPIRES'}     && defined $query{'EXPIRES'} );
    $Job->{'timelag'}     = $query{'TIMELAG'}     if ( exists $query{'TIMELAG'}     && defined $query{'TIMELAG'} );

    if ( $typeID == 1 )
    {
        ## PATCHSTATUS ##
        $Job->{'name'}        = $query{'NAME'} || 'Patchstatus Job';
        $Job->{'description'} = $query{'DESCRIPTION'} || "Patchstatus Job for Client $GUID";
        $Job->{'persistent'}  = $query{'PERSISTENT'} || 1;
        $Job->{'timelag'}     = $query{'TIMELAG'} || '23:00';
    }
    elsif ( $typeID == 2 )
    {
        ## SOFTWARE PUSH ##

        if ( not @SWpackagelist || @SWpackagelist == 0 )
        {
            print __("Please define at least one package for a software push job.");
            exit 3;
        }

        $Job->{'name'}        = $query{'NAME'} || 'Software Push';        
        $Job->{'description'} = $query{'DESCRIPTION'} || sprintf("Software Push: %s", join(', ', @SWpackagelist) );
        $Job->{'arguments'}   = { 'packages' => [ { 'package' => \@SWpackagelist } ] };
        $Job->{'arguments'}{'force'} = $SWforce if (defined $SWforce);
        $Job->{'arguments'}{'agreelicenses'} = $SWagree if (defined $SWagree);
    }
    elsif ( $typeID == 3 )
    {
        ## update ##
        $Job->{'name'}        = $query{'NAME'} || 'Update Job';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Update Job';
        $Job->{'arguments'}{'agreelicenses'} = $SWagree if (defined $SWagree);
    }
    elsif ( $typeID == 4 )
    {
        ## exec ##
        $Job->{'name'}        = $query{'NAME'} || 'Execute';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Execute custom command';
        $Job->{'arguments'}{'command'} = (exists $para{'EXECCOMMAND'} && defined $para{'EXECCOMMAND'}) ? $para{'EXECCOMMAND'} : ' /bin/true ' ;
    }
    elsif ( $typeID == 5 )
    {
        ## reboot ##
        $Job->{'name'}        = $query{'NAME'} || 'Reboot';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Reboot now';
    }
    elsif ( $typeID == 6 )
    {
        ## configure ##
        print __("This job type is reserved for future use.")."\n";
        exit 1;
    }
    elsif ( $typeID == 7 )
    {
        ## wait ##
        my $sec = $para{'WAITTIME'} || '1';
        my $ret = $para{'WAITSTATUS'} || '0';

        $Job->{'name'}        = $query{'NAME'} || sprintf("Wait %s sec. for exit %s.", $sec, $ret );
        $Job->{'description'} = $query{'DESCRIPTION'} || sprintf("Wait for %s seconds and return with value %s.", $sec, $ret );
        $Job->{'arguments'}{'waittime'} = $sec;
        $Job->{'arguments'}{'exitcode'} = $ret;
    }
    elsif ( $typeID == 8 )
    {
        ## eject ##
        $Job->{'name'}        = $query{'NAME'} || 'Eject job';
        $Job->{'description'} = $query{'DESCRIPTION'} || 'Job to eject the CD/DVD drawer';
        $Job->{'arguments'}{'action'} = (exists $para{'ACTION'} && defined $para{'ACTION'}) ? $para{'ACTION'} : 'open' ;
    }
    else
    {
        print __("This job type is unsupported.")."\n";
        exit 3;
    }

    my $newjobid = undef;
    if (@guid > 0)
    {
        ##  job for multiple guids ##
        $newjobid = $JobQ->addJobForMultipleGUIDs($Job, @guid);
    }
    else
    {
        ## single job ##
        $newjobid = $Job->save();
    }

    if ( $newjobid )
    {
        print sprintf(__("Successfully created new job. The job id is: %s"), $newjobid )."\n" unless $quiet;
 
        # for new softwarepush and update jobs automatcally add a patchstatus job to refresh the patchstatus immediately
        # can be disabled by --no-autopatchstatus / it is enabled by default
        if ( ( $typeID == 2  ||  $typeID == 3 )  &&  $autoPatchstatus )
        {
            my $PSjob = SMT::Job->new({ 'dbh' => $dbh });
            $PSjob->newJob( @guid > 0 ? undef:$GUID, undef, 1, undef );

            $PSjob->{'name'}        =  'Automatic Patchstatus Job';
            $PSjob->{'description'} =  sprintf("Automatic Patchstatus Job after job ID %s", $newjobid);
            $PSjob->{'parent_id'}  = $newjobid;
 
            my $newPSjobid = undef;
            if (@guid > 0)
            {
                $newPSjobid = $JobQ->addJobForMultipleGUIDs($PSjob, @guid);
            }
            else
            {
                $newPSjobid = $PSjob->save();
            }

            if ( $newPSjobid ) 
            {
                print sprintf(__("Successfully created an automatic patchstatus job. The job id is: %s"), $newPSjobid )."\n" unless $quiet;
            }
            else
            {
                print  __("An error occurred when creating an automatic patchstatus job.")."\n";
            }
        }

    }
    else
    {
        print __("An error occurred when creating a new job.")."\n";
    }


}
elsif ( defined $edit )
{
    ## EDIT  ##

    if ( (not defined $GUID) || ( not defined $jobid ) )
    {
        print __("Please define one job id and one guid to edit a job.")."\n";
        exit 3;
    }

    # get job data from database
    $Job->readJobFromDatabase($jobid, $GUID);

    # overwrite with new values
    my @EditProps = qw(NAME DESCRIPTION VERBOSE PERSISTENT PARENT_ID TARGETED EXPIRES TIMELAG);
    foreach my $eprop (@EditProps)
    {
        $Job->{lc($eprop)} = $query{uc($eprop)} if ( exists $query{uc($eprop)}  && defined $query{uc($eprop)} );
    }

    # save job
    my $result = $Job->save();
    if ($result)
    {
        print __("Successfully saved the edited job.")."\n" unless $quiet;
    }
    else
    {
        print __("An error occurred when saving the edited job.")."\n";
    }
}
elsif ( defined $delete )
{
    ##  DELETE  ##
    my $DELguid = undef;
    my $DELjobid = undef;
    
    if ( (not defined $jobid)  &&  (not defined $GUID) )
    {
        print __("To delete a job please define a job ID and the GUID of the client or either of these together with --deleteall.");
        exit 3;
    }
    elsif ( defined $jobid  &&  defined $GUID )
    {
        print sprintf(__("Deleting job %s for guid %s."), $jobid, $GUID )."\n" unless $quiet;
        $DELguid=$GUID;
        $DELjobid=$jobid;
    }
    else
    {
        if ( not defined $jobid )
        {
            if ( not $deleteall )
            {
                print __("The job id is invalid.")."\n";
                exit 3;
            }
            print sprintf(__("Deleting all jobs for guid %s."), $GUID )."\n" unless $quiet;
            $DELguid=$GUID;
            $DELjobid='ALL';
        }
        if ( not defined $GUID )
        {
            if ( not $deleteall )
            {
                print __("The guid is invalid.")."\n";
                exit 3;
            }
            print sprintf(__("Deleting all jobs with id  %s for all guids."), $jobid )."\n" unless $quiet;
            $DELguid='ALL';
            $DELjobid=$jobid;
        }
    }

    my $JobQ = SMT::JobQueue->new({ 'dbh' => $dbh });

    if ( not $JobQ->deleteJob($DELjobid, $DELguid) )
    {
        if ($deleteall)
        {
            print sprintf(__("An error occurred when deleting job %s for all guids."), $jobid )."\n" unless $quiet;
        }
        else
        {
            print sprintf(__("An error occurred when deleting job %s for guid %s."), $jobid, $GUID )."\n" unless $quiet;
        }
    }
    else
    {
        print __("Successfully deleted job.")."\n" unless $quiet;
    }
}
else
{
    ## LIST  ##

    if ( not defined $JobQ )
    {
        print __("Can not query the job queue.")."\n";
        exit 3;
    }

    # make sure we select all data
    $query{'selectAll'} = '';
    my $res = $JobQ->getJobsInfo(\%query);

    # reder the result
    my $t = new Text::ASCIITable;

    # basic job list info - without a --verbose switch
    my @DPROP = qw(ID GUID NAME TYPE STATUS);
    $verbose = 0 if (not $verbose);

    # set the level of verbosity
    if ($verbose == 1)
    {
        @DPROP = qw(ID GUID NAME TYPE PERSISTENT STATUS FINISHED);
    }
    elsif ($verbose == 2)
    {
        @DPROP = qw(ID PARENT_ID GUID NAME TYPE VERBOSE PERSISTENT STATUS FINISHED DESCRIPTION);
    }
    elsif ($verbose == 3)
    {
        @DPROP = qw(ID PARENT_ID GUID NAME TYPE VERBOSE PERSISTENT STATUS FINISHED TARGETED EXPIRES TIMELAG DESCRIPTION);
    }

    # create the column titles
    my @cols = ();
    foreach my $prop (@DPROP)
    {
        my $copyprop = $prop; 
        $copyprop =~ s/PARENT_ID/PARENT/;
        push( @cols, ucfirst(lc($copyprop)) );
    }    
    $t->setCols(@cols);

    my $p = '';
    my $h = undef;
    my $onerow = [];

    # process job data, sort by client id and job id (bnc#514678)
    # rewrite JOB_TYPE and JOB_STATUS
    foreach my $xcid ( sort keys %{$res} )
    {
        foreach my $xjid ( sort keys %{${$res}{$xcid}} ) 
        {
            $onerow = [];
            $h = ${$res}{$xcid}{$xjid};

            foreach $p (@DPROP)
            {
                if ($p eq 'TYPE')   { ${$h}{$p} = ${$h}{$p} =~ /^\d+$/ ? JOB_TYPE->{${$h}{$p}}   : ${$h}{$p}  }
                if ($p eq 'STATUS') { ${$h}{$p} = ${$h}{$p} =~ /^\d+$/ ? JOB_STATUS->{${$h}{$p}} : ${$h}{$p} }
                push(@{$onerow}, defined ${$h}{$p} ?  ${$h}{$p}:'');
            }
            $t->addRow($onerow);
        }
    }

    # set the heading
    # disable heading, as rendering takes too long then
    # $t->setOptions('headingText', __('Found jobs in SMT job queue'));    
    print $t->draw();
    print "\n";
}


exit 0;

########################################################################################
#
# Manpage
#

=head1 NAME

smt-job

=head1 SYNOPSIS

smt-job <operation mode> [OPTION [OPTION ...]]

=head1 DESCRIPTION

C<smt-job> manages jobs for smt clients. It allows to list, create, edit and delete jobs like patchstatus or softwarepush.

=head1 OPTIONS

=head2 BASIC OPTIONS

=over

=item -h, --help

Shows the help screen.

=item -v, --verbose <level>

Shows detailed job information in list mode ( level supports values from 0 to 3 ).

=item -q, --quiet

Quiet mode, suppresses success messages.

=back

=head2 OPERATION MODES

=over

=item -l, --list

Lists jobs. This mode is the default if the operation mode is omitted.

=item -c, --create

Creates a new job.

=item -e, --edit

Edits a job. 

=item -d, --delete

Deletes a job.

=back

=head2 MAIN PARAMETERS

=over

=item -g, --guid <guid>

Specifies the client's guid. This paramater can be used multiple times when 
creating a job in order to create a job for more than one client.

=item -j, --jobid <id>

Specifies the job ID. This will be ignored when creating a job.
Note: Editing and deleting a job requires a job ID and client's guid, as the same job
for multiple clients has the same job ID.

=item -A, --deleteall

Allows to omit either the client's guid or the job ID parameter in delete operation, the missing parameter will 
then match all clients resp. jobs.

=back

=head2 PARAMETERS FOR SEARCHING OR CHANGING

=over

=item -t, --type <type> 

Specifies the job type (e.g.  C<patchstatus>, C<softwarepush>, C<update>, C<execute>, C<reboot>, C<wait>, C<eject>).
B<Note:> Only C<patchstatus> and C<softwarepush> are enabled by default on the client.

=item -n --name <name>

Specifies a job name

=item --decription

Specifies a job description

=item --parent <id>

Specifies the job id of the parent job. This is used in order to describe a dependency.
A job won't be processed until its parent has successfully finished.

=item -V, --verbosejob

Specifies whether a job is verbose. Verbose jobs return stdout and stderr.

=item --no-verbosejob

Opposite of C<--verbosejob>.

=item --persistent

Specifies whether a job is persistent. Non-persistent jobs are procressed only once, while persistent 
jobs are processed again and again. Please use C<--timelag> to define the time that elapses until the next run.

=item --no-persistent

Opposite of C<--persistent>.

=item --finished

Search option for finished jobs.

=item --no-finished

Opposite of C<--finished>.




=back

=head2 PARAMETERS FOR TIMING

=over

=item --targeted <time>  

Specifies the earliest execution time of a job in the format C<'YYYY-MM-DD[-HH:MM[:SS]]>. Please note that 
the job most likely won't run exactly at that point in time but probably some minutes/hours after, because
the client polls in a fixed interval for jobs.

=item --expires <time>

Defines when the job will no longer be executed anymore. Use the time format C<'YYYY-MM-DD[-HH:MM[:SS]]>.

=item --timelag <time>

Defines the interval for persistent jobs in the format C<HH:MM[:SS]>.

=back

=head2 JOB SPECIFIC PARAMETERS (only for creating a job)

=head3 softwarepush

=over

=item -P, --package <pack>

Defines a package name to be installed or updated. This paramater can be used multiple times if you want to 
specify more than one package.

=item -F, --forceinstall

Enforces installation of a packages, it is reinstalled even if the latest version is installed already.

=item --no-forceinstall

Opposite of C<--foreceinstall>. Default is not to enforce the installation.


=item --agreelicense

By using this option, you choose to agree with licenses of all third-party software that will be installed.

=item --no-agreelicense

Opposite of C<--agreelicense>. Default is not to agree to licenses.


=item --autopatchstatus

Enables to automatically add a B<patchstatus> job after a B<softwarepush> or B<update> job. This will update the patchstatus information immediately after a software installation on the client.
Otherwise there might be a gap of upto 26 hours until it gets refreshed. B<Note:> Default is to automatically add a patchstatus job.

=item --no-autopatchstatus

Opposite of C<--autopatchstatus>

=back

=head3 update

=over

=item --agreelicenses

By using this option, you choose to agree with licenses of all third-party software that will be installed.

=item --no-agreelicense

Opposite of C<--agreelicense>. Default is not to agree to licenses.

=item --autopatchstatus

Enables to automatically add a B<patchstatus> job after a B<softwarepush> or B<update> job. This will update the patchstatus information immediately after a software installation on the client.
Otherwise there might be a gap of upto 26 hours until it gets refreshed. B<Note:> Default is to automatically add a patchstatus job.

=item --no-autopatchstatus

Opposite of C<--autopatchstatus>

=back

=head3 execute

=over

=item -X, -exec <command>

This paramater defines the commandline to execute on the client.

=back

=head3 wait

=over

=item --waittime <time>

Time in seconds the job should take.

=item --waitstatus <exit>

The exit code for the job to return with.

=back

=head3 eject

=over

=item --action

The action of CD or DVD tray: C<open>, C<close> or C<toggle>.


=back

=head1 EXAMPLES

=over

=item List all finished jobs with a few details:

# smt-job --list --finished -v 1

=item Create a softwarepush job that updates C<xterm> and C<bash> on client C<12345> and C<67890>:

# smt-job --create -t softwarepush -P xterm -P bash -g 12345 -g 67890

=item Change the timing for a persistent job with job ID C<42> and guid C<12345>  to run every 6 hours:

It is necessary to update the targeted time as well as persistent jobs always add their timelag to the current targeted time.

# smt-job --edit -j 42 -g 12345 --targeted 0000-00-00 --timelag 06:00:00

=item Delete all jobs with job ID C<42>

# smt-job --delete -jobid 42 --deleteall 

=item Show everything known about jobid C<42>:

# smt-job --list -j 42 -v 3

=back

=head1 AUTHORS and CONTRIBUTORS

Jens Daniel Schmidt, Thomas Goettlicher

=cut


=head1 LICENSE

Copyright (c) 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
