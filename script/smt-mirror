#!/usr/bin/env perl

###########################################################################
## Copyright (c) 2007 SUSE LINUX Products GmbH, Nuernberg, Germany.
###########################################################################

use SMT::Mirror::NU;
use SMT::Mirror::RpmMd;
use SMT::Mirror::Yum;
use SMT::Utils;
use SMT::CLI;
use SMT::Parser::RegData;
use Config::IniFiles;
use File::Path;
use URI;
use Getopt::Long;
use File::Basename;
use File::Temp;
use Time::HiRes qw(gettimeofday tv_interval);

use Locale::gettext ();
use POSIX ();     # Needed for setlocale()

POSIX::setlocale(&POSIX::LC_MESSAGES, "");

#use Data::Dumper;

my $debug    = 0;
my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2;

my $clean    = 0;
my $hardlink = 0;
my $deepverify = 0;
my $dryrun     = 0;

my $dbreplfile = undef;
my $dbreplacement = {};

my $LocalBasePath = "";

my $help     = 0;
my $logfile = "/dev/null";
my $mail     = 0;
my $mailtempfile = undef;

my $download = 0;
my $link = 0;
my $copy = 0;
my $errors = 0;
my $size = 0;

my $nolink = 0;

my $result = GetOptions ("debug|d"      => \$debug,
                         "verboselevel|v=i" => \$vblevel,
                         "cleanup|c"    => \$clean,
                         "hardlink=i"   => \$hardlink,
                         "directory=s"  => \$LocalBasePath,
                         "deepverify"   => \$deepverify,
                         "dryrun|n"     => \$dryrun,
                         "nohardlink"   => \$nohardlink,
                         "dbreplfile=s" => \$dbreplfile,
                         "logfile|L=s"  => \$logfile,
                         "help|h"       => \$help,
                         "mail|m"       => \$mail
                        );


if($help)
{
    print basename($0) . " [--directory path] [--deepverify] [--dryrun] [--dbreplfile file] [-L file] [--debug] [--verboselevel level] [--nohardlink] [--mail]\n";
    print basename($0) . " --clean [--directory path] [--dbreplfile file] [-L file] [--debug]\n";
    print basename($0) . " --hardlink size [--directory path] [-L file] [--debug]\n";
    print "\n";
    print __("Options:\n");
    print "--debug -d              " . __("enable debug mode\n");
    print "--verboselevel -v level " . __("set the verbose level\n");
    print "--clean -c              " . __("cleanup all mirrored repositories.\n");
    print "                        " . __("Remove all files no longer mentioned in the metadata.\n");
    print "                        " . __("It does not mirror new files.\n");
    print "--hardlink size         " . __("Search for duplicate files with size > 'size' (in Kilobytes) and create hardlinks\n");
    print "                        " . __("for them\n");
    print "--directory arg         " . __("The directory to work on. Using this option ignores the configured\n");
    print "                        " . __("default value in smt.conf\n");
    print "--deepverify            " . __("Verify all checksums \n");
    print "--dryrun -n             " . __("Run mirror algorithm without downloading the rpms \n");
    print "                        " . __("(but it needs to download the metadata into a temporary directory).\n");
    print "                        " . __("It shows only the names which would be downloaded \n");
    print "--nohardlink            " . __("If a file already exists on the local harddisk do not link it into the\n");
    print "                        " . __("mirrored repository, but copy it.\n");
    print "--dbreplfile arg        " . __("Path to XML file to use as database replacement. Such a file can\n");
    print "                        " . __("be created with the sync-ncc command. This option is only\n");
    print "                        " . __("useful if the smt database does not exist on the host from\n"); 
    print "                        " . __("which the smt-mirror script is being executed.\n");
    print "--mail -m               " . __("Send output as e-mail to the administrators defined in reportEmail in smt.conf.\n");
    print "                        " . __("The output on stdout and stderr will be suppressed.\n");
    print "--logfile -L file       " . __("Path to logfile\n");
    exit 0;
}

my $mirrorStartTime = [gettimeofday] ;

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);


if($mail)
{
    my $dir = File::Temp::tempdir("smt-XXXXXXXX", CLEANUP => 1, TMPDIR => 1);
    $mailtempfile = "$dir/mail";
    open(STDOUT, "> $mailtempfile") or die "Cannot open file:$!";
    open(STDERR, ">&STDOUT") or die "Cannot dup:$!";
}


# get a lock

if(!SMT::Utils::openLock("smt-mirror"))
{
    print __("Mirror process is still running.\n");
    exit 0;
}

# open the logfile

my $LOG = SMT::Utils::openLog($logfile);

my $cfg = undef;

eval
{
    $cfg = SMT::Utils::getSMTConfig();
};
if($@ || !defined $cfg)
{
    if(!SMT::Utils::unLock("smt-mirror"))
    {
        SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR,  __("Cannot remove lockfile."));
    }
    SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, sprintf(__("Cannot read the SMT configuration file: %s"), $@));
    exit 1;
}

if(!defined $LocalBasePath || $LocalBasePath eq "" )
{
    $LocalBasePath = $cfg->val("LOCAL", "MirrorTo");
    if(!defined $LocalBasePath || $LocalBasePath eq "" || !-d $LocalBasePath)
    {
        if(!SMT::Utils::unLock("smt-mirror"))
        {
            SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
        }
        SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot read the local base path"));
        exit 1;
    }
}
else
{
    if(!-d $LocalBasePath)
    {
        # directory does not exists, try to create it.
        eval {
            &File::Path::mkpath($LocalBasePath);
        };
        if ($@) 
        {
            SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, sprintf(__("Cannot create %s: %s"), $LocalBasePath, $@));
            if(!SMT::Utils::unLock("smt-mirror"))
            {
                SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
            }
            exit 1;
        }
    }
}


if($hardlink > 0)
{
    SMT::CLI::hardlink(log => $LOG, size => $hardlink, vblevel => $vblevel, basepath => $LocalBasePath);
    
    if(!SMT::Utils::unLock("smt-mirror"))
    {
        SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR,  __("Cannot remove lockfile."));
    }
    exit 0;
}


my $dbh = undef;

if(!defined $dbreplfile)
{
    $dbh = SMT::Utils::db_connect($cfg);
    
    if(!$dbh)
    {
        if(!SMT::Utils::unLock("smt-mirror"))
        {
            SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR,  __("Cannot remove lockfile."));
        }
        SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR,  __("Cannot connect to database"));
        exit 1;
    }
}
else
{
    # add a parser
    $dbreplacement = {};
    
    my $parser = SMT::Parser::RegData->new();
    $parser->parse( $dbreplfile, sub { catalog_handler($dbreplacement, @_); });
}


#print Data::Dumper->Dump([$dbreplacement]);


my $NUUrl = $cfg->val("NU", "NUUrl");
if(!defined $NUUrl || $NUUrl eq "")
{
    if(!SMT::Utils::unLock("smt-mirror"))
    {
        SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
    }
    SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot read NU Url"));
}

my $nuUser = $cfg->val("NU", "NUUser");
my $nuPass = $cfg->val("NU", "NUPass");

if(!defined $nuUser || $nuUser eq "" ||
   !defined $nuPass || $nuPass eq "")
{
    if(!SMT::Utils::unLock("smt-mirror"))
    {
        SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
    }
    SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot read the Mirror Credentials"));
    exit 1;
}

my $uri = URI->new($NUUrl);
$uri->userinfo("$nuUser:$nuPass");


my $mirrorsrc = $cfg->val("LOCAL", "MirrorSRC");
if(defined $mirrorsrc && lc($mirrorsrc) eq "false")
{
    $mirrorsrc = 0;
}
else
{
    $mirrorsrc = 1;
}

my $hash = {};

if(!defined $dbreplfile)
{
    #
    # search for all zypp repositories we need to mirror and start the mirror process
    #
    $hash = $dbh->selectall_hashref( "select CATALOGID, LOCALPATH, EXTURL, EXTHOST, CATALOGTYPE from Catalogs where (CATALOGTYPE='zypp' or CATALOGTYPE='yum') and MIRRORABLE='Y' and DOMIRROR='Y'", "CATALOGID" );
}
else
{
    $hash = $dbreplacement;
}

foreach my $id (keys %{$hash})
{
    next if(!exists $hash->{$id}->{CATALOGTYPE} || ! defined $hash->{$id}->{CATALOGTYPE});

    if( (lc($hash->{$id}->{CATALOGTYPE}) eq "zypp" || lc($hash->{$id}->{CATALOGTYPE}) eq "yum") && 
        $hash->{$id}->{EXTURL} ne "" && $hash->{$id}->{LOCALPATH} ne "" )
    {
        my $zuri = URI->new($hash->{$id}->{EXTURL});
        if($zuri->host eq "nu.novell.com")
        {
            $zuri->userinfo("$nuUser:$nuPass");
        }
        
        &File::Path::mkpath( SMT::Utils::cleanPath( $LocalBasePath, "repo", $hash->{$id}->{LOCALPATH} ) );

        my $zyppMirror = undef;
        if( lc($hash->{$id}->{CATALOGTYPE}) eq "yum")
        {
            $zyppMirror = SMT::Mirror::Yum->new(vblevel => $vblevel, log => $LOG, dbh => $dbh,
                                                mirrorsrc => $mirrorsrc, nohardlink => $nohardlink);
        }
        else
        {
            $zyppMirror = SMT::Mirror::RpmMd->new(vblevel => $vblevel, log => $LOG, dbh => $dbh,
                                                  mirrorsrc => $mirrorsrc, nohardlink => $nohardlink);
        }        
        $zyppMirror->localBasePath( SMT::Utils::cleanPath( $LocalBasePath, "repo" ) );
        $zyppMirror->localRepoPath( $hash->{$id}->{LOCALPATH} );
        
        if($clean)
        {
            $zyppMirror->clean();
        }
        else
        {
            $zyppMirror->uri( $zuri->as_string );
            $zyppMirror->deepverify($deepverify);
            $zyppMirror->mirror( dryrun => $dryrun );

            my $s = $zyppMirror->statistic();
            $download += $s->{DOWNLOAD};
            $link     += $s->{LINK};
            $copy     += $s->{COPY};
            $errors   += $s->{ERROR};
            $size     += $s->{DOWNLOAD_SIZE};
        }
    }
}

#
# Now mirror the NU catalogs
#
my $mirror = SMT::Mirror::NU->new(vblevel => $vblevel, log => $LOG, mirrorsrc => $mirrorsrc, dbh => $dbh, nohardlink => $nohardlink);
$mirror->deepverify($deepverify);
$mirror->localBasePath( SMT::Utils::cleanPath( $LocalBasePath, "repo" ) );
if($clean)
{
    $mirror->clean();
}
else
{
    if(defined $dbreplfile)
    {
        $mirror->dbreplacement($dbreplacement);
    }
    
    $mirror->uri( $uri->as_string );
    $mirror->mirror( dryrun => $dryrun );

    my $s = $mirror->statistic();
    $download += $s->{DOWNLOAD};
    $link     += $s->{LINK};
    $copy     += $s->{COPY};
    $errors   += $s->{ERROR};
    $size     += $s->{DOWNLOAD_SIZE};
}

# search for Catalogs which has the DOMIRROR flag equals Y but the MIRRORABLE flag to N
if(!defined $dbreplfile)
{
    $hash = $dbh->selectall_hashref( "select CATALOGID, NAME, TARGET, CATALOGTYPE from Catalogs where MIRRORABLE='N' and DOMIRROR='Y'", "CATALOGID" );
    
    if(keys %{$hash} > 0)
    {
    
        my $warning = __("WARNING: The following Catalogs cannot be mirrored.\n");
        $warning   .= __("         Maybe you have not enough permissions to download these Catalogs?\n\n");
        
        foreach my $id (keys %{$hash})
        {
            $warning .= "* ".$hash->{$id}->{NAME}." ".$hash->{$id}->{TARGET}."\n";
        }

        SMT::Utils::printLog($LOG, $vblevel, LOG_WARN, $warning);
    }
}

if(!SMT::Utils::unLock("smt-mirror"))
{
    SMT::Utils::printLog($LOG, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
    exit 1;
}


if(!$clean && !$hardlink)
{
    # print summary only when mirroring
    my @summary = ();
    
    push @summary, __("Summary");
    push @summary, sprintf(__("Total transfered files    : %d "), $download );
    push @summary, sprintf(__("Total transfered file size: %d (%s)"), $size, SMT::Utils::byteFormat($size));
    push @summary, sprintf(__("Total linked files        : %s"), $link);
    push @summary, sprintf(__("Total copied files        : %s"), $copy);
    push @summary, sprintf(__("Errors:                   : %d"), $errors);
    push @summary, sprintf(__("Total Mirror Time         : %s"), SMT::Utils::timeFormat(tv_interval($mirrorStartTime)));
    
    if(!$mail)
    {
        foreach my $str (@summary)
        {
            SMT::Utils::printLog($LOG, $vblevel, (LOG_INFO1|LOG_INFO2), $str);
        }
    }
    else
    {
        my $body = "";
        foreach my $str (@summary)
        {
            SMT::Utils::printLog($LOG, $vblevel, (LOG_INFO1|LOG_INFO2), $str, 0, 1);
            $body .= $str."\n";
        }
        $body .= "\n";
        
        close (STDOUT);
        
        open(MAIL, "< $mailtempfile") and do
        {
            while(<MAIL>)
            {
                $body .= $_;
            }
            close MAIL;
        };
        my $datestring = POSIX::strftime("%Y-%m-%d %H:%M", localtime);
        my $subject = "SMT Mirror Report $datestring -- $errors Errors";
        SMT::Utils::sendMailToAdmins($subject, $body);
    }
    
    #
    # does not make sense here. If a complete repo is up-to-date we do not have the number of files
    #
    #SMT::Utils::printLog($LOG, $vblevel, LOG_INFO1, sprintf(__("Files up to date          : %s"), $uptodate));

}


exit 0;

sub catalog_handler
{
    my $data = shift;
    my $node = shift;

    #print "called ".Data::Dumper->Dump([$node])."\n";

    if(defined $node && ref($node) eq "HASH" && 
       exists $node->{MAINELEMENT} && defined $node->{MAINELEMENT} &&
       lc($node->{MAINELEMENT}) eq "catalogs")
    {
        my $catname = $node->{NAME};
        if(exists $node->{TARGET} && defined $node->{TARGET} && $node->{TARGET} ne "")
        {
            $catname .= "-".$node->{TARGET};
        }
        #print "Build Catalogname $catname\n";        
        $data->{$catname} = $node;
    }        
}

#
# Manpage
#

=head1 NAME

smt mirror 

=head1 SYNOPSIS

smt [help|--help|-h] mirror

smt mirror [--directory path] [--deepverify] [--dryrun] [--dbreplfile file] [-L file] [--debug] [--verboselevel level] [--nohardlink] [--mail]

smt mirror --clean [--directory path] [--dbreplfile file] [-L file] [--debug] [--verboselevel level]

smt mirror --hardlink size [--directory path] [-L file] [--debug] [--verboselevel level]

=head1 DESCRIPTION

C<smt mirror> performs the mirroring procedure and downloads catalogs which are set to be mirrored.

If it is called with the B<--clean> parameter it searches inside of the mirrored catalogs for
obsolete files and remove them.

The B<--hardlink> paramter cause C<smt mirror> to search for files greater then I<size>. If it finds 
duplicate files it creates hardlinks instead of holding two copies of the same file.


=head1 OPTIONS

=head2 MIRROR

=over

=item --directory <path>

Defined the directory (B<path>) to work on. Using this option ignores the configured
default value in smt.conf

=item --deepverify

Before starting the mirror procedure verify checksums of B<all> files in the catalogs
and remove broken files. without this option only the metadata are verified.

=item --dryrun -n

Run mirror procedure without downloading the rpms (but it needs to download the metadata into a temporary directory).
It shows only the names which would be downloaded.

=item --dbreplfile <file>

Path to XML file to use as database replacement. Such a file can      
be created with the sync-ncc command. This option is only
useful if the smt database does not exist on the host from 
which the smt-mirror script is being executed.

=item --logfile -L <file>

Write log messages to B<file>.

=item --debug -d

Enable debug mode.

=item --verboselevel -v <level>

Set the output verbose level. The following categories exists. 
These categories can be bitwise-or'd to use as verbose level.

=over 4

=item error messages

Value: 0x0001 == 1

=item warning messages

Value: 0x0002 == 2

=item info messages 1

Value: 0x0004 == 4

=item info messages 2

Value: 0x0008 == 8

=item debug messages 1

Value: 0x0010 == 16

=item debug messages 2

Value: 0x0020 == 32

=back

The default verbose level is 15 (error, warning and all info messages).
B<--debug> set the verbose level to 63.

=item --nohardlink

Instead of using hardlinks, copy the files.

=item --mail -m

Send output as e-mail to the administrators defined in reportEmail in smt.conf .
The output on stdout and stderr will be suppressed in this mode.

=back

=head2 CLEAN

=over

=item --clean

Enable clean mode. With this parameter C<smt mirror> searches inside of the mirrored catalogs for
obsolete files and remove them. It does not mirror new files. 

=item --directory <path>

Defined the directory (B<path>) to work on. Using this option ignores the configured
default value in smt.conf

=item --dbreplfile <file>

Path to XML file to use as database replacement. Such a file can be created with
the sync-ncc command. This option is only usefull if the smt database is not on the
same host as this script should run.

=item --logfile -L <file>

Write log messages to B<file>.

=item --debug -d

Enable debug mode.

=item --verboselevel -v <level>

Set the output verbose level. 

=back

=head2 HARDLINK

=over

=item --hardlink <size>

The B<--hardlink> paramter cause C<smt mirror> to search for files greater then I<size> (in kb).
If it finds duplicate files (equal in name, size and checksum), it creates hardlinks instead
of holding two copies of the same file.

=item --directory <path>

Defined the directory (B<path>) to work on. Using this option ignores the configured
default value in smt.conf

=item --logfile -L <file>

Write log messages to B<file>.

=item --debug -d

Enable debug mode.

=item --verboselevel -v <level>

Set the output verbose level. 

=back

=head1 EXAMPLES

Start the mirror procedure with logging

 smt mirror --logfile /var/log/smt-mirror.log

start the mirror procedure with logging and a different verbose level

 smt mirror -v 11 --logfile /var/log/smt-mirror.log

run mirror with verifing all checksums and debug mode

 smt mirror -d --deepverify

clean the catalogs from files, which are no longer mentioned in the metadata

 smt mirror --clean 

create hardlinks for all duplicate files greater then 20000 kb

 smt mirror --hardlink 20000

=head1 AUTHORS and CONTRIBUTORS

Duncan Mac-Vicar Prett, Lukas Ocilka, Jens Daniel Schmidt, Michael Calmer

=head1 LICENSE

Copyright (c) 2008 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
