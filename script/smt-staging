#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;

use Getopt::Long;
use File::Basename;
use Text::ASCIITable;

use SMT::Utils;
use SMT::Repositories;
use SMT::Filter;
use SMT::Mirror::Utils;
use SMT::Mirror::RpmMd;
use SMT::Parser::RpmMdPatches;


my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2;
my $debug    = 0;
my $logfile = "/dev/null";
my $help     = 0;

my $dbreplfile = undef;
my $dbreplacement = [];
my $FromLocalBasePath = "";
my $fromlocalsmt = 0;

my $gentest = 0;
my $genprod = 0;
my $nohardlink = 0;
my $LocalBasePath = ""; # TODO what's this about

my @patches = ();
my $category = undef;

my $options = GetOptions("testing|t"    => \$gentest,
                         "production|p" => \$genprod,
                         "nohardlink"   => \$nohardlink,
                         "directory=s"  => \$LocalBasePath,
                         "patch=s"      => \@patches,
                         "category=s"   => \$category,

                         "fromdir=s"    => \$FromLocalBasePath,
                         "fromlocalsmt" => \$fromlocalsmt,
                         "dbreplfile=s" => \$dbreplfile,

                         "debug|d"      => \$debug,
                         "verboselevel|v=i" => \$vblevel,
                         "logfile|L=s"  => \$logfile,
                         "help|h"       => \$help,
                        );

sub printhelp
{
    my $scriptname = shift;

    print $scriptname . " listupdates <repository> [--forbidden] [--allowed]\n";
    print $scriptname . " forbid      <repository> [--patch <patch> ... | --category <category>]\n";
    print $scriptname . " allow       <repository> [--patch <patch> ... | --category <category>]\n";
    print $scriptname . " createrepo  <repository> --testing|--production [--nohardlink]\n";
    print "\n";
    print __("Repository can be specified using its name and target or ID\n");
    print __("from smt-repos output.\n");
    print "\n";
    print __("Options:\n");
    print "--testing -t            " . __("Generate testing repository with selected updates.\n");
    print "--production -p         " . __("Generate production repository with selected updates.\n");
    #print "--hardlink size         " . __("Search for duplicate files with size > 'size' (in Kilobytes) and create hardlinks\n");
    #print "                        " . __("for them\n");
    #print "--directory arg         " . __("The directory to work on. Using this option ignores the configured\n");
    #print "                        " . __("default value in smt.conf\n");
    #print "--fromdir arg           " . __("Mirror from the directory give here, instead of mirroring from the remote sources.\n");
    #print "                        " . __("The directory can e.g. be created by calling smt-mirror --directory\n");
    #print "--fromlocalsmt          " . __("Mirror from the local running SMT server. This options requires the --directory\n");
    #print "                        " . __("option being set. The resulting directory can  e.g later be imported to another server\n");
    #print "                        " . __("using smt-mirror --fromdir\n");
    print "--nohardlink            " . __("If a file already exists on the local harddisk do not link it into the\n");
    print "                        " . __("mirrored repository, but copy it.\n");
    print "--debug -d              " . __("Enable debug mode.\n");
    print "--verboselevel -v level " . __("Set the level of verbosity.\n");
    print "--logfile -L file       " . __("Log to specified file.\n");
}

if ($help)
{
    printhelp(basename($0));
    exit 0;    
}

if(!SMT::Utils::dropPrivileges())
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

if (@ARGV < 2)
{
    print STDERR __("Too few arguments. At least a command and repository ID are required.\n");
    print "\n";
    printhelp(basename($0));
    exit 1;
}

# the first non-option argument is the command

my $command = undef;
if (!($ARGV[0] eq 'createrepo' ||
      $ARGV[0] eq 'listupdates' ||
      $ARGV[0] eq 'forbid' ||
      $ARGV[0] eq 'allow'))
{
    printf STDERR __("Unknown command '%s'\n"), $ARGV[0];
    print "\n";
    printhelp(basename($0));
    exit 1;
}
else
{
    $command = shift @ARGV;
}

# the second is the repository id or name (if there is the third argument)
my $reponameid = shift @ARGV;

# the third (optional) is always the repository target (from the smt-repos output)
my $target = shift @ARGV;

# get a lock

if(!SMT::Utils::openLock("smt-staging"))
{
    print __("Other staging process is still running.\n");
    exit 0;
}

# open the logfile

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);
my $log = SMT::Utils::openLog($logfile);

# get the config

my $cfg = undef;
eval
{
    $cfg = SMT::Utils::getSMTConfig();
};
if($@ || !defined $cfg)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf(__("Cannot read the SMT configuration file: %s"), $@));
    SMT::Utils::unLockAndExit( "smt-mirror", 1, $log, $vblevel );
}

# connect to database (all commands need it)

my $dbh = SMT::Utils::db_connect();
if(!$dbh)
{
    if(!SMT::Utils::unLock("smt-staging"))
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
    }
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, __("Cannot connect to database."));
    exit 1;
}

# get the repository from DB (all commands need it)

my $rh = SMT::Repositories::new($dbh, $log);
my $repo = $rh->getRepository($reponameid) if (not defined $target);
my $repoid = undef;
$rh->getAndClearErrorMessage();

if (not defined $repo)
{
    if (not defined $target)
    {
        # not found by CATALOGID, lets try by ID (row number) from smt-repos

        my $repos = $rh->getAllRepositories();
        my $err = $rh->getAndClearErrorMessage();
        my $count = scalar keys %$repos;

        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, 'DB error: ' . $err)
            if ($err);

        if ( $reponameid =~ /^[0-9]+$/ &&
            int($reponameid) > 0 && int($reponameid) <= $count)
        {
            my $id = 1;
            foreach my $r (keys %$repos)
            {
                if ($id == int($reponameid))
                {
                    $repo = $repos->{$r};
                    $repoid = $r;
                    last;
                }
                $id++;
            }
        }
        else
        {
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
                sprintf __("Repository ID '%s' not found."), $reponameid);
            printf __("Use '%s' to list all available repositories.\n"), 'smt-repos';
            SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
        }
    }
    # try to find by name & target
    else
    {
        my $repos = $rh->getAllRepositories({
            SMT::Repositories::NAME => $reponameid,
            SMT::Repositories::TARGET => $target
        });

        my $count = scalar keys %$repos; 
        if ($count <= 0)
        {
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
                sprintf __("Repository named '%s' with target '%s' not found."), $reponameid, $target);
            printf __("Use '%s' to list all available repositories.\n"), 'smt-repos';
            SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
        }
        elsif ($count == 1)
        {
            $repo = $repos;
        }
        else
        {
            # select manually
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
                sprintf __("Multiple repositories named '%s' with target '%s' found."), $reponameid, $target);
            print "Selection from multiple not implemented. Use repository ID.\n";
            SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
        }
    }
}
else
{
    SMT::Utils::printLog($log, $vblevel, LOG_DEBUG,
        sprintf "Found repository by CATALOGID '%s'.", $reponameid);
    $repoid = $reponameid;
}

# check if we can do staging for this repo

my $canstage = $rh->stagingAllowed($repoid, $cfg->val("LOCAL", "MirrorTo"));
my $error = $rh->getAndClearErrorMessage();
if ($error)
{
    print $error . "\n";
}
elsif (!$canstage)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
        sprintf __("Staging is not allowed for repository '%s', target '%s'."), $repo->{NAME}, $repo->{TARGET});
    print __("The repository either does not contain update metadata, or the metadata are in an unsupported format.\n");
    print __("Only openSUSE 11.x, SLE-11, and Fedora/RedHat XX? repositories are supported.\n");
    SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
}

# now we're ready to do the real work

my $localrepopath = SMT::Utils::cleanPath(
    $cfg->val("LOCAL", "MirrorTo"), "repo/full", $repo->{LOCALPATH});


###############################################################################
# list the udates
###############################################################################

if ($command eq 'listupdates')
{
        
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $parser = SMT::Parser::RpmMdPatches->new(
        log => $log,
        vblevel => $vblevel);
    $parser->resource($localrepopath);
    my $patches = $parser->parse("repodata/updateinfo.xml.gz");
    
    my $t = new Text::ASCIITable;
    $t->setCols(__("Allowed"), __("Name"), __("Version"), __("Category"), __("Summary"));
    foreach my $patch (values %$patches)
    {
        my $allowed = not $filter->matches($patch);
        $t->addRow(($allowed ? __("Yes") : __("No")), $patch->{name}, $patch->{version}, $patch->{type}, $patch->{title}); 
    }
    if (%$patches)
    {
        print $t->draw();
    }
    else
    {
        print __("This repository does not contain any patches.") . "\n";
    }
}

###############################################################################
# forbid an update
###############################################################################

elsif ($command eq 'forbid')
{
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    if (@patches)
    {
        # TODO make sure user gave name-version, check if such patch exists, ...
        $filter->add(SMT::Filter->TYPE_NAME_VERSION, $_) foreach @patches;
    }
    elsif (defined $category && $category)
    {
        # TODO check if the category is known
        $filter->add(SMT::Filter->TYPE_SECURITY_LEVEL, $category);
    }
    else
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, "No patches specified.");
        print __("Specify at list one '--patch name-version'.") . "\n";
        print __("Use 'smt-staging listupdates' to see the list of available patches.") . "\n";
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    $filter->save($dbh, $repoid);
}

###############################################################################
# allow an update
###############################################################################

elsif ($command eq 'allow')
{
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    if (@patches)
    {
        $filter->remove(SMT::Filter->TYPE_NAME_VERSION, $_) foreach @patches;
    }
    elsif (defined $category)
    {
        # TODO check if the category is known
        $filter->remove(SMT::Filter->TYPE_SECURITY_LEVEL, $category);
    }
    else
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, "No patches specified.");
        print __("Specify at list one '--patch name-version'.") . "\n";
        print __("Use 'smt-staging listupdates' to see the list of available patches.") . "\n";
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    $filter->save($dbh, $repoid);
}

###############################################################################
# create testing/production repo
###############################################################################

elsif ($command eq 'createrepo')
{
    if ($gentest && $genprod)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("Options %s and %s cannot be used together."), '--testing', '--production');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }
    elsif (!($gentest || $genprod))
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("%s or %s?"), '--testing', '--production');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    my $basepath = $cfg->val("LOCAL", "MirrorTo");
    my $localtargetrepopath = ($gentest ?
        $rh->getTestingRepoPath($repoid) :
        $rh->getProductionRepoPath($repoid));

    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $mirror = SMT::Mirror::RpmMd->new(
        log        => $log,
        vblevel    => $vblevel,
        filter     => $filter,
        nohardlink => $nohardlink);

    $mirror->uri('file://'.$localrepopath);
    $mirror->localBasePath($basepath);
    $mirror->localRepoPath($localtargetrepopath);

    my $errcnt = $mirror->mirror(force => 1);
    if ($errcnt)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, 'Something went wrong');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }
    else
    {
        SMT::Mirror::Utils::copyStatus($localrepopath,
            SMT::Utils::cleanPath($basepath, $localtargetrepopath));
        SMT::Utils::printLog($log, $vblevel, LOG_INFO1, sprintf __("Repository successfully generated at %s."), $localtargetrepopath);
    }
}

SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
