#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;

use Getopt::Long;
use File::Basename;
use Text::ASCIITable;

use SMT::Utils;
use SMT::Repositories;
use SMT::Filter;
use SMT::Mirror::Utils;
use SMT::Mirror::RpmMd;
use SMT::Parser::RpmMdPatches;
use SMT::Parser::FilteredRepoChecker;

my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2;
my $debug    = 0;
my $logfile = "/dev/null";
my $help     = 0;

my $dbreplfile = undef;
my $dbreplacement = [];
my $FromLocalBasePath = "";
my $fromlocalsmt = 0;

my $gentest = 0;
my $genprod = 0;
my $nohardlink = 0;
my $LocalBasePath = ""; # TODO what's this about

my @patches = ();
my $category = undef;

my $optres = GetOptions("testing|t"    => \$gentest,
                        "production|p" => \$genprod,
                        "nohardlink"   => \$nohardlink,
                        "directory=s"  => \$LocalBasePath,
                        "patch=s"      => \@patches,
                        "category=s"   => \$category,
                        
                        "fromdir=s"    => \$FromLocalBasePath,
                        "fromlocalsmt" => \$fromlocalsmt,
                        "dbreplfile=s" => \$dbreplfile,
                        
                        "debug|d"      => \$debug,
                        "verboselevel|v=i" => \$vblevel,
                        "logfile|L=s"  => \$logfile,
                        "help|h"       => \$help,
                       );

sub printhelp
{
    my $scriptname = shift;

    print $scriptname . " listupdates <repository>\n";
    print "    [--patch <patch> ... | --category <category>]\n";
    print "\n";
    print $scriptname . " forbid <repository>\n";
    print "    [--patch <patch> ... | --category <category>]\n";
    print "\n";
    print $scriptname . " allow <repository>\n";
    print "    [--patch <patch> ... | --category <category>]\n";
    print "\n";
    print $scriptname . " createrepo <repository>\n";
    print "    --testing|--production [--nohardlink]\n";
    print "\n";
    print $scriptname . " --help | -h\n";
    print "\n";
    print __("Repository can be specified using its name and target or ID\n");
    print __("from smt-repos output.\n");
    print "\n";
    print __("Options:\n");
    print "--testing          (-t) " . __("Generate testing repository with selected updates.\n");
    print "--production       (-p) " . __("Generate production repository with selected updates.\n");
    print "--patch <name-ver>      " . __("Specify patch to forbid or allow using name and version.\n");
    print "--category <category>   " . __("Specify patch category to forbid or allow.\n");
    print "                        " . __("Choose one of: recommended, security, optional.\n");
    #print "--hardlink size         " . __("Search for duplicate files with size > 'size' (in Kilobytes) and create hardlinks\n");
    #print "                        " . __("for them\n");
    #print "--directory arg         " . __("The directory to work on. Using this option ignores the configured\n");
    #print "                        " . __("default value in smt.conf\n");
    #print "--fromdir arg           " . __("Mirror from the directory give here, instead of mirroring from the remote sources.\n");
    #print "                        " . __("The directory can e.g. be created by calling smt-mirror --directory\n");
    #print "--fromlocalsmt          " . __("Mirror from the local running SMT server. This options requires the --directory\n");
    #print "                        " . __("option being set. The resulting directory can  e.g later be imported to another server\n");
    #print "                        " . __("using smt-mirror --fromdir\n");
    print "--nohardlink            " . __("If a file already exists on local filesystem, do not\n");
    print "                        " . __("link it into the mirrored repository. Copy it instead.\n");
    print "--debug            (-d) " . __("Enable debug mode.\n");
    print "--verboselevel     (-v) " . __("Set the level of verbosity.\n");
    print "--logfile <file>   (-L) " . __("Log to specified file.\n");
}

if ($help || !$optres)
{
    printhelp(basename($0));
    exit 0;    
}

if(!SMT::Utils::dropPrivileges())
{
    print STDERR __("Unable to drop privileges. Abort!\n");
    exit 1;
}

if (@ARGV < 2)
{
    print STDERR __("Too few arguments. At least a command and repository ID are required.\n");
    print "\n";
    printhelp(basename($0));
    exit 1;
}

# the first non-option argument is the command

my $command = undef;
if (!($ARGV[0] eq 'createrepo' ||
      $ARGV[0] eq 'listupdates' ||
      $ARGV[0] eq 'forbid' ||
      $ARGV[0] eq 'allow'))
{
    printf STDERR __("Unknown command '%s'\n"), $ARGV[0];
    print "\n";
    printhelp(basename($0));
    exit 1;
}
else
{
    $command = shift @ARGV;
}

# the second is the repository id or name (if there is the third argument)
my $reponameid = shift @ARGV;

# the third (optional) is always the repository target (from the smt-repos output)
my $target = shift @ARGV;

# get a lock

if(!SMT::Utils::openLock("smt-staging"))
{
    print __("Other staging process is still running.\n");
    exit 0;
}

# open the logfile

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);
my $log = SMT::Utils::openLog($logfile);

# get the config

my $cfg = undef;
eval
{
    $cfg = SMT::Utils::getSMTConfig();
};
if($@ || !defined $cfg)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf(__("Cannot read the SMT configuration file: %s"), $@));
    SMT::Utils::unLockAndExit( "smt-mirror", 1, $log, $vblevel );
}

# connect to database (all commands need it)

my $dbh = SMT::Utils::db_connect();
if(!$dbh)
{
    if(!SMT::Utils::unLock("smt-staging"))
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
    }
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, __("Cannot connect to database."));
    exit 1;
}

# get the repository from DB (all commands need it)

my $rh = SMT::Repositories::new($dbh, $log);
my $repo = $rh->getRepository($reponameid) if (not defined $target);
my $repoid = undef;
$rh->getAndClearErrorMessage();

if (not defined $repo)
{
    if (not defined $target)
    {
        # not found by CATALOGID, lets try by ID (row number) from smt-repos

        my $repos = $rh->getAllRepositories();
        my $err = $rh->getAndClearErrorMessage();
        my $count = scalar keys %$repos;

        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, 'DB error: ' . $err)
            if ($err);

        if ( $reponameid =~ /^[0-9]+$/ &&
            int($reponameid) > 0 && int($reponameid) <= $count)
        {
            my $id = 1;
            foreach my $r (keys %$repos)
            {
                if ($id == int($reponameid))
                {
                    $repo = $repos->{$r};
                    $repoid = $r;
                    last;
                }
                $id++;
            }
        }
        else
        {
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
                sprintf __("Repository ID '%s' not found."), $reponameid);
            printf __("Use '%s' to list all available repositories.\n"), 'smt-repos';
            SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
        }
    }
    # try to find by name & target
    else
    {
        my $repos = $rh->getAllRepositories({
            SMT::Repositories::NAME => $reponameid,
            SMT::Repositories::TARGET => $target
        });

        my $count = scalar keys %$repos; 
        if ($count <= 0)
        {
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
                sprintf __("Repository named '%s' with target '%s' not found."), $reponameid, $target);
            printf __("Use '%s' to list all available repositories.\n"), 'smt-repos';
            SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
        }
        elsif ($count == 1)
        {
            $repo = $repos;
        }
        else
        {
            # select manually
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
                sprintf __("Multiple repositories named '%s' with target '%s' found."), $reponameid, $target);
            print "Selection from multiple not implemented. Use repository ID.\n";
            SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
        }
    }
}
else
{
    SMT::Utils::printLog($log, $vblevel, LOG_DEBUG,
        sprintf "Found repository by CATALOGID '%s'.", $reponameid);
    $repoid = $reponameid;
}

# check if we can do staging for this repo

my $canstage = $rh->stagingAllowed($repoid, $cfg->val("LOCAL", "MirrorTo"));
if (not defined $canstage)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
        sprintf __("Cannot determine whether staging is allowed for repository '%s', target '%s'."), $repo->{NAME}, $repo->{TARGET});
    print __("See the log for more details.\n");
    SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
}
elsif (!$canstage)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
        sprintf __("Staging is not allowed for repository '%s', target '%s'."), $repo->{NAME}, $repo->{TARGET});
    print __("The repository either does not contain update metadata, or the metadata are in an unsupported format.\n");
    print __("Only openSUSE 11.x, SLE-11, and Fedora/RedHat XX? repositories are supported.\n");
    SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
}

# now we're ready to do the real work

my $localfullrepopath = SMT::Utils::cleanPath(
    $cfg->val("LOCAL", "MirrorTo"), "repo/full", $repo->{LOCALPATH});

# list of known patch categories
my %exists_category = (
    'recommended'   => 1,
    'security'      => 1,
    'optional'      => 1);


###############################################################################
# list the udates
###############################################################################

if ($command eq 'listupdates')
{
    if (defined $category && not $exists_category{$category})
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, "Invalid category '$category'.", 0);
        print sprintf (__("Invalid category '%s'."), $category) . "\n";
        print sprintf (__("See '%s' for the list of known categories."), 'man smt-staging') . "\n";
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $parser = SMT::Parser::RpmMdPatches->new(
        log => $log,
        vblevel => $vblevel);
    $parser->resource($localfullrepopath);
    my $patches = $parser->parse("repodata/updateinfo.xml.gz");
    
    if (@patches)
    {
        if (defined $category)
        {
            print sprintf (__("Cannot use %s when %s is specified. Ignoring."),
                '--category', '--patch') . "\n";
        }
        
        foreach (@patches)
        {
            if (not defined $patches->{$_})
            {
                SMT::Utils::printLog($log, $vblevel, LOG_WARN,
                    sprintf (__("Patch '%s' not found."), $_));
                next;
            }

            my $patch = $patches->{$_};
            my $allowed = not $filter->matches($patch);
            print $_ . "\n";
            print (('-' x length $_) . "\n");
            my $ident = '    ';
            print $ident . __('Name: ') . $patch->{name} . "\n";
            print $ident . __('Version: ') . $patch->{version} . "\n";
            print $ident . __('Category: ') . $patch->{type} . "\n";
            print $ident . __('Summary: ') . $patch->{title} . "\n";
            print $ident . __('Allowed: ') . ($allowed ? __("Yes") : __("No")) . "\n";
            
            if (not $allowed)
            {
                print $ident . __('Filtered by:') . "\n";
                for (@{$filter->whatMatches($patch)})
                {
                    print $ident;
                    if ($_->[0] == SMT::Filter::TYPE_NAME_VERSION)
                    { print '- ' . sprintf (__('Patch ID \'%s\''), $_->[1]) }
                    elsif ($_->[0] == SMT::Filter::TYPE_SECURITY_LEVEL)
                    { print '- ' . sprintf (__('Patch category \'%s\''), $_->[1]) }
                    elsif ($_->[0] == SMT::Filter::TYPE_NAME_REGEX)
                    { print '- ' . sprintf (__('Regular expression \'%s\''), $_->[1]) }

                    print "\n";
                }
            }
            
            print $ident . __('Description: ') . "\n" .
                $patch->{description} . "\n\n";
        }
    }
    else
    {
        my $t = new Text::ASCIITable;
        $t->setCols(
            __("Allowed"),
            __("Name"), 
            __("Version"),
            __("Category"),
            __("Summary"));
        foreach my $patch (values %$patches)
        {
            next if ($category && $patch->{type} ne $category);
            
            my $allowed = not $filter->matches($patch);
            $t->addRow(($allowed ? __("Yes") : __("No")),
                $patch->{name},
                $patch->{version},
                $patch->{type},
                $patch->{title}); 
        }
        if (%$patches)
        {
            print $t->draw();
        }
        else
        {
            print __("This repository does not contain any patches.") . "\n";
        }
    }
}


###############################################################################
# allow/forbid an update
###############################################################################

elsif ($command eq 'allow' || $command eq 'forbid')
{
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $allow = $command eq 'allow';

    if (@patches)
    {
        if (defined $category)
        {
            print sprintf (__("Cannot use %s when %s is specified. Ignoring."),
                '--category', '--patch') . "\n";
        }
        if ($allow)
        {
            $filter->remove(SMT::Filter->TYPE_NAME_VERSION, $_) foreach @patches;
        }
        else
        {
            # TODO make sure user gave name-version, check if such patch exists, ...
            $filter->add(SMT::Filter->TYPE_NAME_VERSION, $_) foreach @patches;
        }
    }
    elsif (defined $category)
    {
        if ($exists_category{$category})
        {
            if ($allow)
            {
                $filter->remove(SMT::Filter->TYPE_SECURITY_LEVEL, $category);
            }
            else
            {
                $filter->add(SMT::Filter->TYPE_SECURITY_LEVEL, $category);
            }
        }
        else
        {
            SMT::Utils::printLog($log, $vblevel, LOG_ERROR, "Invalid category '$category'.", 0);
            print sprintf (__("Invalid category '%s'."), $category) . "\n";
            print sprintf (__("See '%s' for the list of known categories."), 'man smt-staging') . "\n";
            SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
        }
    }
    else
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, "No patches specified.");
        print __("Specify at least one '--patch name-version'.") . "\n";
        print __("Use 'smt-staging listupdates' to see the list of available patches.") . "\n";
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    # check consistency of the resulting repository before applying changes
    my $checker = SMT::Parser::FilteredRepoChecker->new(log => $log, vblevel => $vblevel); 
    $checker->repoPath($localfullrepopath);
    $checker->filter($filter);
    printLog ($log, $vblevel, LOG_DEBUG, 'checking dependencies', 0);
    my ($result, $problems, $causes) = $checker->check();
    printLog ($log, $vblevel, LOG_DEBUG, 'DONE checking dependencies', 0);

    if (not $result)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
            __("Dependecy problems found."));

        foreach my $pkg (keys %$problems)
        {
            printLog ($log, $vblevel, LOG_ERROR, sprintf (
                __("Cannot remove package '%s' required by forbidden patch '%s'.\n"),
                $pkg, $causes->{$pkg}));

            printLog ($log, $vblevel, LOG_ERROR, sprintf (
                __("The package is needed by patch '%s', which is allowed.\n"),
                $problems->{$pkg}));
        }

        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    $filter->save($dbh, $repoid);
}

###############################################################################
# create testing/production repo
###############################################################################

elsif ($command eq 'createrepo')
{
    if ($gentest && $genprod)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("Options %s and %s cannot be used together."), '--testing', '--production');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }
    elsif (!($gentest || $genprod))
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("%s or %s?"), '--testing', '--production');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    my $mirrorsrc = $cfg->val("LOCAL", "MirrorSRC");
    if (defined $mirrorsrc && lc($mirrorsrc) eq "false")
    { $mirrorsrc = 0; }
    else
    { $mirrorsrc = 1; }

    my $basepath = $cfg->val("LOCAL", "MirrorTo");

    # source
    my $testingrepopath = $basepath.'/'.$rh->getTestingRepoPath($repoid); 
    my $sourcerepourl = 'file://';
    # generate the production repo from the testing repo, not full
    # TODO: check the testing repo status using the SMT::Mirror:Utils
    if (! $gentest && -e $testingrepopath . '/repodata/repomd.xml')
    { $sourcerepourl .= $testingrepopath; }
    else
    { $sourcerepourl .= $localfullrepopath; }

    # target
    my $localtargetrepopath = ($gentest ?
        $rh->getTestingRepoPath($repoid) :
        $rh->getProductionRepoPath($repoid));
    

    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $mirror = SMT::Mirror::RpmMd->new(
        log        => $log,
        vblevel    => $vblevel,
        filter     => $filter,
        nohardlink => $nohardlink,
        mirrorsrc  => $mirrorsrc);

    $mirror->uri($sourcerepourl);
    $mirror->localBasePath($basepath);
    $mirror->localRepoPath($localtargetrepopath);

    my $errcnt = $mirror->mirror(force => 1);
    if ($errcnt)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, 'Something went wrong');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }
    else
    {
        SMT::Mirror::Utils::copyStatus($localfullrepopath,
            SMT::Utils::cleanPath($basepath, $localtargetrepopath));
        SMT::Utils::printLog($log, $vblevel, LOG_INFO1, sprintf __("Repository successfully generated at %s."), $localtargetrepopath);
    }
}

SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );

#
# Manpage
#

=head1 NAME

smt staging

=head1 SYNOPSIS

smt staging <command> <repository> [options]

smt staging listupdates <repository> [general-options]
    [--patch <patch> ... | --category <category>]

smt staging forbid <repository> [general-options]
    [--patch <patch> ... | --category <category>]

smt staging allow <repository> [general-options]
    [--patch <patch> ... | --category <category>]

smt staging createrepo <repository> [general-options]
    --testing|--production [--nohardlink]

smt staging --help | -h

=head1 DESCRIPTION

C<smt staging> script allows setting up patch (update) filters for update
repositories and generate repositories for testing or use in production
environment.

Use the B<listupdates> command to list available patches and their
allowed/forbidden status, B<allow>/B<forbid> commands to allow or forbid
specified patches, and, finally B<createrepo> to generate testing or production
repository containing only allowed patches.

=head1 TERMINOLOGY

=over 4

=item patch

An update of a package or group of packages. The term I<update> and I<patch> are
interchangable throughout this manual and in the C<smt staging> script. 

=back

=head1 ARGUMENTS

The first argument of C<smt staging> is always the B<command>. The command must
be followed by I<repository>. Repository can be specified using the I<ID> or
I<Name and Target> from the table returned by C<smt repos>. The third alternative
is to use the hexadecimal I<Repository ID> found in C<smt repos -v> output.

Example:

=over 4

=item $ smt staging createrepo 1 --testing

creates testing repository from repository number 1 from C<smt repos> table.

=back

=head1 GENERAL OPTIONS

The following options apply to any command.

=over 4

=item -L, --logfile <filepath>

Write log to the specified file. If the file does not exist, it will be
created. 

=item -d, --debug

Turn on debugging output and log.

=item -v, --verbose 

Enable more detailed output.

=back


=head1 COMMAND-SPECIFIC OPTIONS

=over 4

=item --patch

Specify a patch using its ID, that is 'I<patchname-version>'. To get a list
of available patches, use the B<listupates> command. This option can be
used multiple times.

This option is used in the B<allow>, B<forbid>, and B<listupdates> commands.

If used in B<listupdates>, the command will print detailed information about
the specified patches. 

=item --category

Specify patch (update) category. The following categories are available:
 security
 recommended
 optional

This option is used in the B<allow>, B<forbid>, and B<listupdates> commands. 

=item --testing

Used in the B<createrepo> command to generate a repository for testing.
The testing repository will be generated from the full unfiltered local mirror
of the remote repository and written into <MirrorTo>/repo/testing directory,
where MirrorTo is the value taken from the smt.conf configuration file.

=item --production

Used in the B<createrepo> command to generate a repository for production use.
This command should be used after testing have been made on the testing
reposity.

The 'production' repository will be generated from the testing repository
and written into <MirrorTo>/repo directory, where MirrorTo is the value taken
from the smt.conf configuration file. If the testing repository does not exist,
the production repository will be generated from the full unfiltered local
mirror of the remote repository.

=item --nohardlink

Avoid creating of hard links instead of copying files when creating
the testing or production repositories using B<createrepo> command.
If not specified, hard links are created instead of copying wherever possible
to save space and time.

=back

=head1 AUTHORS and CONTRIBUTORS

Jan Kupec

=head1 LICENSE

Copyright (c) 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA.

=cut
