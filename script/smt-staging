#!/usr/bin/perl

###############################################################################
## Copyright (c) 2007, 2008, 2009 SUSE LINUX Products GmbH, Nuernberg, Germany.
###############################################################################

use strict;
use warnings;

use Getopt::Long;
use File::Basename;

use SMT::Utils;
use SMT::Repositories;
use SMT::Filter;
use SMT::Mirror::Utils;
use SMT::Mirror::RpmMd;
use SMT::Parser::RpmMdPatches;

my $vblevel  = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2;
my $debug    = 0;
my $logfile = "/dev/null";
my $help     = 0;

my $dbreplfile = undef;
my $dbreplacement = [];
my $FromLocalBasePath = "";
my $fromlocalsmt = 0;

my $gentest = 0;
my $genprod = 0;
my $nohardlink = 0;
my $LocalBasePath = ""; # TODO what's this about

my $options = GetOptions("testing|t"    => \$gentest,
                         "production|p" => \$genprod,
                         "nohardlink"   => \$nohardlink,
                         "directory=s"  => \$LocalBasePath,

                         "fromdir=s"    => \$FromLocalBasePath,
                         "fromlocalsmt" => \$fromlocalsmt,
                         "dbreplfile=s" => \$dbreplfile,

                         "debug|d"      => \$debug,
                         "verboselevel|v=i" => \$vblevel,
                         "logfile|L=s"  => \$logfile,
                         "help|h"       => \$help,
                        );

if($help)
{
    print basename($0) . " listupdates <repoid> [--forbidden] [--allowed]\n";
    print basename($0) . " forbid      <repoid> <patch>\n";
    print basename($0) . " allow       <repoid> <patch>\n";
    print basename($0) . " createrepo  <repoid> --testing|--production [--nohardlink]\n";
    print "\n";
    print __("Options:\n");
    print "--testing -t            " . __("Generate testing repository with selected updates.\n");
    print "--production -p         " . __("Generate production repository with selected updates.\n");
    #print "--hardlink size         " . __("Search for duplicate files with size > 'size' (in Kilobytes) and create hardlinks\n");
    #print "                        " . __("for them\n");
    #print "--directory arg         " . __("The directory to work on. Using this option ignores the configured\n");
    #print "                        " . __("default value in smt.conf\n");
    #print "--fromdir arg           " . __("Mirror from the directory give here, instead of mirroring from the remote sources.\n");
    #print "                        " . __("The directory can e.g. be created by calling smt-mirror --directory\n");
    #print "--fromlocalsmt          " . __("Mirror from the local running SMT server. This options requires the --directory\n");
    #print "                        " . __("option being set. The resulting directory can  e.g later be imported to another server\n");
    #print "                        " . __("using smt-mirror --fromdir\n");
    print "--nohardlink            " . __("If a file already exists on the local harddisk do not link it into the\n");
    print "                        " . __("mirrored repository, but copy it.\n");
    print "--debug -d              " . __("Enable debug mode.\n");
    print "--verboselevel -v level " . __("Set the level of verbosity.\n");
    print "--logfile -L file       " . __("Log to specified file.\n");
    exit 0;
}

if (@ARGV < 2)
{
    print STDERR __("Too few arguments. At least the command and repository ID are required.\n");
    exit 1;
}

#print "Non-option args: @ARGV\n";

# the first non-option argument is the command

my $command = undef;
if (!($ARGV[0] eq 'createrepo' ||
      $ARGV[0] eq 'listupdates' ||
      $ARGV[0] eq 'forbid' ||
      $ARGV[0] eq 'allow'))
{
    printf __("Unknown command '%s'\n"), $ARGV[0];
    exit 1;
}
else
{
    $command = shift @ARGV;
}

# the second is always the repository id

my $repoid = shift @ARGV;

# get a lock

if(!SMT::Utils::openLock("smt-staging"))
{
    print __("Other staging process is still running.\n");
    exit 0;
}

# open the logfile

$vblevel = LOG_ERROR|LOG_WARN|LOG_INFO1|LOG_INFO2|LOG_DEBUG|LOG_DEBUG2 if($debug);
my $log = SMT::Utils::openLog($logfile);

# get the config

my $cfg = undef;
eval
{
    $cfg = SMT::Utils::getSMTConfig();
};
if($@ || !defined $cfg)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf(__("Cannot read the SMT configuration file: %s"), $@));
    SMT::Utils::unLockAndExit( "smt-mirror", 1, $log, $vblevel );
}

# connect to database (all commands need it)

my $dbh = SMT::Utils::db_connect();
if(!$dbh)
{
    if(!SMT::Utils::unLock("smt-staging"))
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, __("Cannot remove lockfile."));
    }
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, __("Cannot connect to database"));
    exit 1;
}

# get the repository from DB (all commands need it)

my $rh = SMT::Repositories::new($dbh);
my $repo = $rh->getRepository($repoid);
if (not defined $repo)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("Repository ID '%s' not found."), $repoid);
    printf __("Use '%s' to list all available repositories.\n"), 'smt-repos';
    SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
}

# check if we can do staging for this repo

my $canstage = $rh->stagingAllowed($repoid, $cfg->val("LOCAL", "MirrorTo"));
my $error = $rh->getAndClearErrorMessage();
if ($error)
{
    echo $error;
}
elsif (!$canstage)
{
    SMT::Utils::printLog($log, $vblevel, LOG_ERROR,
        sprintf __("Staging is not allowed for repository '%s', ID '%s'."), $repo->{NAME}, $repoid);
    print __("The repository either does not contain update metadata, or the metadata are in an unsupported format.\n");
    print __("Only openSUSE 11.x, SLE-11, and Fedora/RedHat XX? repositories are supported.\n");
    SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
}

# now we're ready to do the real work

my $localrepopath = SMT::Utils::cleanPath(
    $cfg->val("LOCAL", "MirrorTo"), "repo/full", $repo->{LOCALPATH});


###############################################################################
# list the udates
###############################################################################

if ($command eq 'listupdates')
{
        
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $parser = SMT::Parser::RpmMdPatches->new(
        log => $log,
        vblevel => $vblevel);
    $parser->resource($localrepopath);
    my $patches = $parser->parse("repodata/updateinfo.xml.gz");
    
    # TODO print nice table
    foreach my $patch (values %$patches)
    {
        my $allowed = not $filter->matches($patch);
        print ( ($allowed ? '*' : ' ') . " | " . $patch->{name} . "\t | " . $patch->{version} . "\t | " . $patch->{title} . "\n"); 
    }
}

###############################################################################
# forbid an update
###############################################################################

elsif ($command eq 'forbid')
{
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    if (@ARGV)
    {
        # TODO make sure user gave name-version, check if such patch exists, ...
        $filter->add(SMT::Filter->TYPE_NAME_VERSION, @ARGV);
    }

    $filter->save($dbh, $repoid);
}

###############################################################################
# allow an update
###############################################################################

elsif ($command eq 'allow')
{
    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    if (@ARGV)
    {
        $filter->remove(SMT::Filter->TYPE_NAME_VERSION, @ARGV); # TODO make remove() accept multiple args
    }

    $filter->save($dbh, $repoid);
}

###############################################################################
# create testing/production repo
###############################################################################

elsif ($command eq 'createrepo')
{
    if ($gentest && $genprod)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("Options %s and %s cannot be used together."), '--testing', '--production');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }
    elsif (!($gentest || $genprod))
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, sprintf __("%s or %s?"), '--testing', '--production');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }

    my $basepath = $cfg->val("LOCAL", "MirrorTo");
    my $localtargetrepopath = ($gentest ?
        $rh->getTestingRepoPath($repoid) :
        $rh->getProductionnRepoPath($repoid));

    my $filter = SMT::Filter->new(log => $log, vblevel => $vblevel);
    $filter->load($dbh, $repoid);

    my $mirror = SMT::Mirror::RpmMd->new(
        log        => $log,
        vblevel    => $vblevel,
        filter     => $filter,
        nohardlink => $nohardlink);

    $mirror->uri('file://'.$localrepopath);
    $mirror->localBasePath($basepath);
    $mirror->localRepoPath($localtargetrepopath);

    my $errcnt = $mirror->mirror();
    if ($errcnt)
    {
        SMT::Utils::printLog($log, $vblevel, LOG_ERROR, 'Something went wrong');
        SMT::Utils::unLockAndExit( "smt-staging", 1, $log, $vblevel );
    }
    else
    {
        SMT::Mirror::Utils::copyStatus($localrepopath,
            SMT::Utils::cleanPath($basepath, $localtargetrepopath));
        SMT::Utils::printLog($log, $vblevel, LOG_INFO1, sprintf __("Repository successfully generated at %s."), $localtargetrepopath);
    }
}

SMT::Utils::unLockAndExit( "smt-staging", 0, $log, $vblevel );
